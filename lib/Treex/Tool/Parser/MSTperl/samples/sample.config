# ParseMSTperl configuration file.

# This config file is in YAML. Preserve the structure as is, including whitespaces.
# Values containing the '#' character must be 'quoted' or "doublequoted". 


# algorithm variant to use for the labeller training and labelling
# (especially regarding the emission probabilities used in the Viterbi algorithm)
# some of them still TODO
# 0 MIRA-trained weights recomputed by +abs(min) and converted to probs,
#   transitions by MLE on labels
# 1 dtto, NOT converted to probs (should be same as 0)
# 2 dtto, sum in Viterbi instead of product (new_prob = old_prob + emiss*trans)
# 3 dtto, no recompution (just strip <= 0)
# 4 basic MLE (no MIRA, no smoothing, uniform feature weights,
#   blind (unigram) transition backoff,
#   blind emission backoff (but should not be necessary))
# 5 full Viterbi (dtto, transition probs lambda smoothing by EM)
#
# 8 completely new, based on reading, no MLE, MIRA for all,
#   same features for label unigrams and label bigrams
# 9 dtto, initialize emissions and transitions by MLE
#
# 10-15 : variants of 0, all differing by only a small change
# 10  0 + fixed best state selection
# 11 10 + tries to use all possible labels
# 12 10 + EM for smoothing of transitions
# 13 11 + EM for smoothing of transitions
# 14 10 + update uses transition probs as well
# 15 12 + update uses transition probs as well
#
# 16  8 + transitions by MLE & EM on label pairs
#     (multiplied with emission score in Viterbi and added to last state score)
# 17  dtto, fixed transition computation for negative scores


labeller_algorithm: 16


# Viterbi n for n-best pruning in labeller

VITERBI_STATES_NUM_THRESHOLD: 1


# Lowercase names of fields in the input file (separated by tab in the file).
# Use [a-z0-9_] only, using always at least one letter.
# Use unique names, i.e. devise some names even for unused fields.
# Treex represents the names as names of attributes of nodes,
# with several special values:
# - parent_ord = ord of the node's parent node
# - coarse_tag = coarse grained tag
# - aligned_* (eg. aligned_pos) = the field on aligned node
# - dummy_* (eg. dummy_1, dummy_2) = ignored field

field_names:
 - ord
 - form
 - lemma
 - pos
 - cpos
 - features
 - parent
 - afun
 - is_member
 - underscore1
 - underscore2


# Values to set for the (technical) root node

root_field_values:
 - 0
 - 
 - 
 - '#root#'
 - '#root#'
 - 
 - -1
 - AuxS
 - 0
 - _
 - _


# Name of field containing ord of parent.

parent_ord: parent

# Name of field containing label of edge from the node's parent to the node.

label: afun

ismember: is_member

# Using cache should be turned on (1) if training with a real lot of RAM or on small
# training data, as it uses a lot of memory but speeds up the training greatly
# (approx. by 30% to 50%). If you need to save RAM, turn it off (0).

use_edge_features_cache: 0

labeller_use_edge_features_cache: 0


# How many times the trainer should go through all the training data
# (default is 10).

number_of_iterations: 3

labeller_number_of_iterations: 3

imlabeller_number_of_iterations: 3


# Buckets to use for distance() function (positive integers in any order)
# Each distance gets bucketed in the highest lower bucket (absolute-value-wise)

distance_buckets:
 - 1
 - 2
 - 3
 - 4
 - 5
 - 10


# Features to be computed on data.
#
# Use lowercase field names (eg. pos) for fields of (child) nodes
# and uppercase field names (eg. POS) for parent nodes,
# joined together by the | sign (eg. POS|LEMMA).
#
# If you do not care for the parent-child role but are interested more in the
# nodes position, use 1.field_name for the field of the two of the nodes
# which appears first in the sentence (i.e. it has lower ord)
# and 2.field_name for the second one (eg. 1.pos for pos of first of the nodes).
#
# There are also several predefined functions that you can make use of:
#   distance(ord_field) - bucketed ord-wise distance of child and parent (ORD minus ord)
#   attdir(ord_field) - parent - child attachement direction: signum(ORD minus ord)
#   preceding(field) - value of the specified field on the ord-wise preceding node
#   (use PRECEDING(field) to get field on node preceding the PARENT)
#   following(field) - the same for ord-wise following node
#   between(field) - value of the specified field for each node which is
#       ord-wise between the child node and the parent node
#   equals(field1,field2) - returns 1 if the value of field1 is the same as
#       the value of field2; for fields with multiple values (eg. with
#       aligned nodes), it has the meaning of an "exists" operator: it returns
#       1 if there is at least one pair of values of each field that are
#       the same.
#       returns 0 if no values match, -1 if (at least) one of the fields is
#       undef (may be also represented by an empty string)
#   equalspc(field1,field2) - like equals but first field is taken from parent
#       and second from child
#   equalspcat(field,position) - like equalspc looks at the given position (1 character)
#       in the given field
#   substr(field,start,length) - substring of field value beginning at given
#       start position (0-based) of given length; standard substr behaviour,
#       i.e. both start and length can be negative and length can be omitted,
#       feature function to be then written as substr(field,start)
#   arrayat(array_field,index_field) - array_field's value is an array of values
#       separated by single spaces (' '), index_field's value is a zero-based
#       index of a value in the array to be returned (used for tree distance)
#   isfirst(ord_field) - returns 1 if node is the first in the sentence, 0 otherwise
#   islast(ord_field) - returns 1 if node is the last in the sentence, 0 otherwise
#   isfirstchild() - returns 1 if node is the first child of its parent, 0 otherwise
#   islastchild() - returns 1 if node is the last child of its parent, 0 otherwise
#   childno() - returns number of node's children
#   islastleftchild() - is the rightmost of all left children of its parent
#   isfirstrightchild() - is the leftmost of all right children of its parent
#   LABEL() - label of parent (to be used only in labeller features);
#       label is somewhat special, it cannot be used as label, LABEL or label()
# Usually you can write the function name in UPPERCASE to invoke in on the parent node,
# eg. CHILDNO() to get the number of parent node's children.
# The parameter of a function must be a (child) field name or an integer
# (as the index in equalspcat).
#

features:
 - CPOS
 - cpos
 - CPOS|cpos
 - LEMMA
 - lemma
 - LEMMA|lemma
 - LEMMA|CPOS
 - lemma|cpos
 - LEMMA|CPOS|cpos
 - LEMMA|CPOS|lemma
 - LEMMA|lemma|cpos
 - CPOS|lemma|cpos
 - LEMMA|CPOS|lemma|cpos
 - PRECEDING(cpos)|CPOS|cpos|following(cpos)
 - PRECEDING(cpos)|CPOS|preceding(cpos)|cpos
 - CPOS|FOLLOWING(cpos)|cpos|following(cpos)
 - CPOS|FOLLOWING(cpos)|preceding(cpos)|cpos
 - CPOS|cpos|following(cpos)
 - CPOS|preceding(cpos)|cpos
 - CPOS|FOLLOWING(cpos)|cpos
 - PRECEDING(cpos)|CPOS|cpos
 - 1.cpos|between(cpos)|2.cpos
# and conjoined with distance
 - distance(ord)|CPOS
 - distance(ord)|cpos
 - distance(ord)|CPOS|cpos
 - distance(ord)|LEMMA
 - distance(ord)|lemma
 - distance(ord)|LEMMA|lemma
 - distance(ord)|LEMMA|CPOS
 - distance(ord)|lemma|cpos
 - distance(ord)|LEMMA|CPOS|cpos
 - distance(ord)|LEMMA|CPOS|lemma
 - distance(ord)|LEMMA|lemma|cpos
 - distance(ord)|CPOS|lemma|cpos
 - distance(ord)|LEMMA|CPOS|lemma|cpos
 - distance(ord)|PRECEDING(cpos)|CPOS|cpos|following(cpos)
 - distance(ord)|PRECEDING(cpos)|CPOS|preceding(cpos)|cpos
 - distance(ord)|CPOS|FOLLOWING(cpos)|cpos|following(cpos)
 - distance(ord)|CPOS|FOLLOWING(cpos)|preceding(cpos)|cpos
 - distance(ord)|CPOS|cpos|following(cpos)
 - distance(ord)|CPOS|preceding(cpos)|cpos
 - distance(ord)|CPOS|FOLLOWING(cpos)|cpos
 - distance(ord)|PRECEDING(cpos)|CPOS|cpos
 - distance(ord)|1.cpos|between(cpos)|2.cpos
# the same features with forms instead of lemmas
 - FORM
 - form
 - FORM|form
 - FORM|CPOS
 - form|cpos
 - FORM|CPOS|cpos
 - FORM|CPOS|form
 - FORM|form|cpos
 - CPOS|form|cpos
 - FORM|CPOS|form|cpos
# and conjoined with distance
 - distance(ord)|FORM
 - distance(ord)|form
 - distance(ord)|FORM|form
 - distance(ord)|FORM|CPOS
 - distance(ord)|form|cpos
 - distance(ord)|FORM|CPOS|cpos
 - distance(ord)|FORM|CPOS|form
 - distance(ord)|FORM|form|cpos
 - distance(ord)|CPOS|form|cpos
 - distance(ord)|FORM|CPOS|form|cpos

 - substr(cpos,0,1)
 - substr(cpos,0,1)|SUBSTR(cpos,0,1)
 - SUBSTR(cpos,0,1)

labeller_features:
 - CPOS
 - cpos
 - CPOS|cpos
 - LEMMA
 - lemma
 - LEMMA|lemma
 - LEMMA|CPOS
 - lemma|cpos
 - LEMMA|CPOS|cpos
 - LEMMA|CPOS|lemma
 - LEMMA|lemma|cpos
 - CPOS|lemma|cpos
 - LEMMA|CPOS|lemma|cpos
 - PRECEDING(cpos)|CPOS|cpos|following(cpos)
 - PRECEDING(cpos)|CPOS|preceding(cpos)|cpos
 - CPOS|FOLLOWING(cpos)|cpos|following(cpos)
 - CPOS|FOLLOWING(cpos)|preceding(cpos)|cpos
 - CPOS|cpos|following(cpos)
 - CPOS|preceding(cpos)|cpos
 - CPOS|FOLLOWING(cpos)|cpos
 - PRECEDING(cpos)|CPOS|cpos
 - 1.cpos|between(cpos)|2.cpos
# new features
 - isfirst(ord)|cpos
 - islast(ord)|cpos
 - isfirstchild()|cpos
 - islastchild()|cpos
 - childno()|cpos
 - CHILDNO()|cpos
 - islastleftchild()|CPOS
 - isfirstrightchild()|CPOS
# parent label features
 - LABEL()
 - cpos|LABEL()
 - CPOS|LABEL()
 - cpos|CPOS|LABEL()

 - substr(cpos,0,1)
 - substr(cpos,0,1)|SUBSTR(cpos,0,1)
 - SUBSTR(cpos,0,1)


imlabeller_features:
 - afun
 - AFUN
 - afun|AFUN
 - CPOS|afun
 - cpos
 - CPOS|cpos
 - CPOS
 - cpos
 - CPOS|cpos
 - LEMMA
 - lemma
 - LEMMA|lemma
 - LEMMA|CPOS
 - lemma|cpos
 - LEMMA|CPOS|cpos
 - LEMMA|CPOS|lemma
 - LEMMA|lemma|cpos
 - CPOS|lemma|cpos
 - LEMMA|CPOS|lemma|cpos
# new features
 - isfirst(ord)|cpos
 - islast(ord)|cpos
 - isfirstchild()|cpos
 - islastchild()|cpos
 - childno()|cpos
 - CHILDNO()|cpos
 - islastleftchild()|CPOS
 - isfirstrightchild()|CPOS
# parent label features
 - ISMEMBER()
 - cpos|ISMEMBER()
 - CPOS|ISMEMBER()
 - cpos|CPOS|ISMEMBER()

 - substr(cpos,0,1)
 - substr(cpos,0,1)|SUBSTR(cpos,0,1)
 - SUBSTR(cpos,0,1)
