# ParseMSTperl configuration file.

# This config file is in YAML. Preserve the structure as is, including whitespaces.
# Values containing the '#' character must be 'quoted' or "doublequoted". 


# algorithm variant to use for the labeller training and labelling
# (especially regarding the emission probabilities used in the Viterbi algorithm)
# some of them still TODO
# 0 MIRA-trained weights recomputed by +abs(min) and converted to probs,
#   transitions by MLE on labels
# 1 dtto, NOT converted to probs (should be same as 0)
# 2 dtto, sum in Viterbi instead of product (new_prob = old_prob + emiss*trans)
# 3 dtto, no recompution (just strip <= 0)
# 4 basic MLE (no MIRA, no smoothing, uniform feature weights,
#   blind (unigram) transition backoff,
#   blind emission backoff (but should not be necessary))
# 5 full Viterbi (dtto, transition probs lambda smoothing by EM)
# 6 approx the correct way hopefully (full Viterbi + MIRA weighting of features,
#   init weights with 100, update with $error,
#   not really probs but prob-like scores)
# 7 the same with fixed best state selection in viterbi
# 8 completely new, based on reading, no MLE, MIRA for all,
#   same features for label unigrams and label bigrams
# 9 dtto, initialize emissions and transitions by MLE

# labeller_algorithm: 8


# Lowercase names of fields in the input file (separated by tab in the file).
# Use [a-z0-9_] only, using always at least one letter.
# Use unique names, i.e. devise some names even for unused fields.
# Treex represents the names as names of attributes of nodes.

field_names:
 - ord
 - form
 - lemma
 - pos
 - cpos
 - features
 - parent
 - afun
 - underscore1
 - underscore2


# Values to set for the (technical) root node

root_field_values:
 - 0
 - 
 - 
 - '#root#'
 - '#root#'
 - 
 - -1
 - AuxS
 - _
 - _


# Name of field containing ord of parent.

parent_ord: parent
label: afun

# Using cache should be turned on (1) if training with a real lot of RAM or on small
# training data, as it uses a lot of memory but speeds up the training greatly
# (approx. by 30% to 50%). If you need to save RAM, turn it off (0).

use_edge_features_cache: 0

labeller_use_edge_features_cache: 0


# How many times the trainer should go through all the training data
# (default is 10).

number_of_iterations: 3

labeller_number_of_iterations: 3


# Buckets to use for distance() function (positive integers in any order)
# Each distance gets bucketed in the highest lower bucket (absolute-value-wise)

distance_buckets:
 - 1
 - 2
 - 3
 - 4
 - 5
 - 10


# Features to be computed on data.
#
# Use lowercase field names (eg. pos) for fields of (child) nodes
# and uppercase field names (eg. POS) for parent nodes,
# joined together by the | sign (eg. POS|LEMMA).
#
# If you do not care for the parent-child role but are interested more in the
# nodes position, use 1.field_name for the field of the two of the nodes
# which appears first in the sentence (i.e. it has lower ord)
# and 2.field_name for the second one (eg. 1.pos for pos of first of the nodes).
#
# There are also several predefined functions that you can make use of:
#   distance(ord_field) - bucketed ord-wise distance of child and parent (ORD minus ord)
#   attdir(ord_field) - parent - child attachement direction: signum(ORD minus ord)
#   preceding(field) - value of the specified field on the ord-wise preceding node
#   (use PRECEDING(field) to get field on node preceding the PARENT)
#   following(field) - the same for ord-wise following node
#   between(field) - value of the specified field for each node which is
#       ord-wise between the child node and the parent node
#   equals(field1,field2) - returns 1 if the value of field1 is the same as
#       the value of field2; for fields with multiple values (eg. with
#       aligned nodes), it has the meaning of an "exists" operator: it returns
#       1 if there is at least one pair of values of each field that are
#       the same.
#       returns 0 if no values match, -1 if (at least) one of the fields is
#       undef (may be also represented by an empty string)
#   equalspc(field1,field2) - like equals but first field is taken from parent
#       and second from child
#   equalspcat(field,position) - like equalspc looks at the given position (1 character)
#       in the given field
#   isfirst(ord_field) - returns 1 if node is the first in the sentence, 0 otherwise
#   islast(ord_field) - returns 1 if node is the last in the sentence, 0 otherwise
#   isfirstchild() - returns 1 if node is the first child of its parent, 0 otherwise
#   islastchild() - returns 1 if node is the last child of its parent, 0 otherwise
#   childno() - returns number of node's children
# Usually you can write the function name in UPPERCASE to invoke in on the parent node,
# eg. CHILDNO() to get the number of parent node's children.
# The parameter of a function must be a (child) field name.
#

features:
 - CPOS
 - cpos
 - CPOS|cpos
 - LEMMA
 - lemma
 - LEMMA|lemma
 - LEMMA|CPOS
 - lemma|cpos
 - LEMMA|CPOS|cpos
 - LEMMA|CPOS|lemma
 - LEMMA|lemma|cpos
 - CPOS|lemma|cpos
 - LEMMA|CPOS|lemma|cpos
 - PRECEDING(cpos)|CPOS|cpos|following(cpos)
 - PRECEDING(cpos)|CPOS|preceding(cpos)|cpos
 - CPOS|FOLLOWING(cpos)|cpos|following(cpos)
 - CPOS|FOLLOWING(cpos)|preceding(cpos)|cpos
 - CPOS|cpos|following(cpos)
 - CPOS|preceding(cpos)|cpos
 - CPOS|FOLLOWING(cpos)|cpos
 - PRECEDING(cpos)|CPOS|cpos
 - 1.cpos|between(cpos)|2.cpos
# and conjoined with distance
 - distance(ord)|CPOS
 - distance(ord)|cpos
 - distance(ord)|CPOS|cpos
 - distance(ord)|LEMMA
 - distance(ord)|lemma
 - distance(ord)|LEMMA|lemma
 - distance(ord)|LEMMA|CPOS
 - distance(ord)|lemma|cpos
 - distance(ord)|LEMMA|CPOS|cpos
 - distance(ord)|LEMMA|CPOS|lemma
 - distance(ord)|LEMMA|lemma|cpos
 - distance(ord)|CPOS|lemma|cpos
 - distance(ord)|LEMMA|CPOS|lemma|cpos
 - distance(ord)|PRECEDING(cpos)|CPOS|cpos|following(cpos)
 - distance(ord)|PRECEDING(cpos)|CPOS|preceding(cpos)|cpos
 - distance(ord)|CPOS|FOLLOWING(cpos)|cpos|following(cpos)
 - distance(ord)|CPOS|FOLLOWING(cpos)|preceding(cpos)|cpos
 - distance(ord)|CPOS|cpos|following(cpos)
 - distance(ord)|CPOS|preceding(cpos)|cpos
 - distance(ord)|CPOS|FOLLOWING(cpos)|cpos
 - distance(ord)|PRECEDING(cpos)|CPOS|cpos
 - distance(ord)|1.cpos|between(cpos)|2.cpos
# the same features with forms instead of lemmas
 - FORM
 - form
 - FORM|form
 - FORM|CPOS
 - form|cpos
 - FORM|CPOS|cpos
 - FORM|CPOS|form
 - FORM|form|cpos
 - CPOS|form|cpos
 - FORM|CPOS|form|cpos
# and conjoined with distance
 - distance(ord)|FORM
 - distance(ord)|form
 - distance(ord)|FORM|form
 - distance(ord)|FORM|CPOS
 - distance(ord)|form|cpos
 - distance(ord)|FORM|CPOS|cpos
 - distance(ord)|FORM|CPOS|form
 - distance(ord)|FORM|form|cpos
 - distance(ord)|CPOS|form|cpos
 - distance(ord)|FORM|CPOS|form|cpos

labeller_features:
# - AFUN (not fully implemented yet)
 - CPOS
 - cpos
 - CPOS|cpos
 - LEMMA
 - lemma
 - LEMMA|lemma
 - LEMMA|CPOS
 - lemma|cpos
 - LEMMA|CPOS|cpos
 - LEMMA|CPOS|lemma
 - LEMMA|lemma|cpos
 - CPOS|lemma|cpos
 - LEMMA|CPOS|lemma|cpos
 - PRECEDING(cpos)|CPOS|cpos|following(cpos)
 - PRECEDING(cpos)|CPOS|preceding(cpos)|cpos
 - CPOS|FOLLOWING(cpos)|cpos|following(cpos)
 - CPOS|FOLLOWING(cpos)|preceding(cpos)|cpos
 - CPOS|cpos|following(cpos)
 - CPOS|preceding(cpos)|cpos
 - CPOS|FOLLOWING(cpos)|cpos
 - PRECEDING(cpos)|CPOS|cpos
 - 1.cpos|between(cpos)|2.cpos
# new features
 - isfirst(ord)|cpos
 - islast(ord)|cpos
 - isfirstchild()|cpos
 - islastchild()|cpos
 - childno()|cpos
 - CHILDNO()|cpos
